#!/usr/bin/env bash

#{{ ansible_managed }}

function perform_restore(){

    # find latest backup file
    echo "Restoring $rst_origin server. Finding latest $origin_file.tgz file..."

    for file in $(find {{ backup_path }} -type f -name *$origin_file.tgz)
    do
        [[ $file -nt $latest_backup ]] && latest_backup=$file
    done

    if [[ -n "$latest_backup" ]]; then

        echo -e "Using $latest_backup file"

        # stop services
        systemctl stop nginx

        # restore file backup
        tar xvzf $latest_backup -C /

        # restore database backup
        mysqldump=$(tar tzf $latest_backup | grep mysqldump)
        mysql < /$mysqldump

        sudo su -s /bin/bash -c "{{ passbolt_bin_path }}/cake passbolt cleanup" {{ passbolt_user }}

        # start services
        systemctl start nginx
        sudo su -s /bin/bash -c "{{ passbolt_bin_path }}/cake passbolt healthcheck" {{ passbolt_user }}
    else
        echo -e "File not found"
    fi
}

function verify_restore_server(){

    shopt -s nocasematch

    if [[ "^master$" =~ $rst_origin ]]; then

        origin_file=passbolt-{{ passbolt_master }};

    elif [[ "^slave$" =~ $rst_origin ]]; then

        origin_file=passbolt-{{ _passbolt_slave }};

    fi

    shopt -u nocasematch

    if [[ -n "$origin_file" ]]; then
        perform_restore
    else
        echo -e "Enter either master or slave to restore..."
    fi
}

function confirm_restore() {

    unset -v latest_backup
    unset -v rst_option
    unset -v rst_origin
    unset -v origin_file

    echo -e "Do you want to restore with Master or Slave database? Master/Slave";
    read rst_origin;

    verify_restore_server
}

function restore_server(){

    unset -v latest_backup
    unset -v rst_option
    unset -v rst_origin
    unset -v origin_file

    rst_origin=$1

    verify_restore_server
}

if [[ $# -eq 0 ]]; then
    confirm_restore
elif [[ $# -eq 1 ]]; then
    restore_server $1
else
    echo "Just one passbolt restore server at a time... Exiting"
    exit 1
fi
